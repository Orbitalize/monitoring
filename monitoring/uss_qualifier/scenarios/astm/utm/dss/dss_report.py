from datetime import datetime, timedelta
from typing import Dict, List

import loguru
from implicitdict import StringBasedDateTime
from uas_standards.astm.f3548.v21.api import (
    Subscription,
    SubscriptionID,
    OPERATIONS,
    OperationID,
    ErrorReport,
    ExchangeRecord,
    ExchangeRecordRecorderRole,
    Time,
)
from uas_standards.astm.f3548.v21.constants import Scope

from monitoring.monitorlib import geo, fetch
from monitoring.monitorlib.fetch import QueryType, QueryError
from monitoring.monitorlib.geo import Polygon, Volume3D
from monitoring.monitorlib.geotemporal import Volume4D
from monitoring.monitorlib.mutate.scd import MutatedSubscription
from monitoring.prober.infrastructure import register_resource_type
from monitoring.uss_qualifier.resources import VerticesResource
from monitoring.uss_qualifier.resources.astm.f3548.v21 import PlanningAreaResource
from monitoring.uss_qualifier.resources.astm.f3548.v21.dss import (
    DSSInstanceResource,
    DSSInstance,
)
from monitoring.uss_qualifier.resources.astm.f3548.v21.planning_area import (
    SubscriptionParams,
)
from monitoring.uss_qualifier.resources.interuss.id_generator import IDGeneratorResource
from monitoring.uss_qualifier.scenarios.astm.utm.dss import test_step_fragments
from monitoring.uss_qualifier.scenarios.astm.utm.dss.validators.subscription_validator import (
    SubscriptionValidator,
)
from monitoring.uss_qualifier.scenarios.scenario import (
    TestScenario,
)
from monitoring.uss_qualifier.suites.suite import ExecutionContext

TIME_TOLERANCE_SEC = 1
"""tolerance when comparing created vs returned timestamps"""

LONGITUDE_MUTATION_SHIFT = 0.001
"""Amount of degrees by which the longitude will be shifted when subscriptions are mutated"""


class DSSReport(TestScenario):
    """
    A scenario that tests the availability of the makeDssReport endpoint
    """

    SUB_TYPE = register_resource_type(385, "DSS Report")

    _dss: DSSInstance
    _report_id: str

    def __init__(self, dss: DSSInstanceResource):
        """
        Args:
            dss: dss to test
        """
        super().__init__()
        scopes = {Scope.StrategicCoordination: "create and delete subscriptions"}
        # This is an UTMClientSession
        self._dss = dss.get_instance(scopes)

    def run(self, context: ExecutionContext):
        self.begin_test_scenario(context)
        self.begin_test_case("DSS Report Endpoint")
        self.begin_test_step("DSS Report Endpoint")

        op = OPERATIONS[OperationID.MakeDssReport]
        path = op.path
        query_type = QueryType.F3548v21DSSMakeDssReport

        body = ErrorReport(
            exchange=ExchangeRecord(
                url="https://example.interuss.org",
                method="GET",
                headers=[],
                recorder_role=ExchangeRecordRecorderRole.Client,
                request_time=Time(value=StringBasedDateTime(datetime.utcnow())),
                response_time=None,
                request_body="",
                response_code=0,
                problem="This is a test report and it may be safely ignored.",
            )
        )

        q = fetch.query_and_describe(
            self._dss.client,
            verb=op.verb,
            url=path,
            json=body,
            query_type=query_type,
            scope=Scope.StrategicCoordination,
        )

        with self.check(
            "DSS report can be submitted", self._dss.participant_id
        ) as check:
            if q.status_code != 201:
                err_msg = q.error_message if q.status_code != 200 else ""
                check.record_failed(
                    summary="DSS report submission failed",
                    details=f"Received {q.status_code} from DSS when 201 was expected: {err_msg}",
                    query_timestamps=[q.request.timestamp],
                )

        with self.check(
            "DSS report response format corresponds to spec", self._dss.participant_id
        ) as check:
            try:
                report = q.parse_json_result(ErrorReport)
            except QueryError as qe:
                check.record_failed(
                    summary="DSS report response format is invalid",
                    details=f"Failed to parse DSS response: {qe.msg}",
                    query_timestamps=[q.request.timestamp],
                )

        with self.check(
            "Report ID is populated by the DSS", self._dss.participant_id
        ) as check:
            report_id = report.report_id if "report_id" in report else None
            if not report_id:
                check.record_failed(
                    summary="Report ID was not populated by the DSS",
                    details=f"The returned report ID is expected to contain a report_id field generated by the DSS. Content: {q.json_result}",
                )

        with self.check(
            "DSS report response content is equal to what was sent",
            self._dss.participant_id,
        ) as check:
            if report.exchange != body.exchange:
                check.record_failed(
                    summary="DSS report response content is not equal to what was sent",
                    details=f"Expected {body.exchange} but got {report.exchange}",
                )

        self.end_test_step()
        self.end_test_case()
        self.end_test_scenario()
